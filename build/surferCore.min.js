function ValidateIPaddress(s, e = "bad entry") {
  return (
    !!/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(
      s
    ) || (alert(e), !1)
  );
}
const sliceBinaryIpAddressString = (s, e) => {
  let r = (j = part = 0),
    d = ["", ""];
  for (; r < s.length; )
    "." != s[r] && j++, (d[part] += s[r]), j > e && (part = 1), r++;
  return d;
};
class IpV4 {
  address = [];
  mask = [];
  maskedAddress = [0, 0, 0, 0];
  constructor(s) {
    this.refreshIp(), this.setSubmask(0);
  }
  refreshIp = () => {
    let s = [];
    for (let e = 0; e < 4; e++) s.push(Math.floor(256 * Math.random()));
    this.address = s;
  };
  setSubmask = (s) => {
    let e = [];
    for (let r = 0; r < 4; r++) {
      let d = Math.min(s, 8);
      e.push(256 - 2 ** (8 - d)), (s -= d);
    }
    this.mask = e;
  };
  addressToBinary = (s) =>
    s.reduce((s, e) => (s.push((e >>> 0).toString(2).padStart(8, "0")), s), []);
  setMaskedAddress = () => {
    let s = this.address.map(Number),
      e = this.mask.map(Number);
    this.maskedAddress = s.map((s, r) => s & e[r]);
  };
  getSlicedBinaryMaskedAddress = (s) =>
    sliceBinaryIpAddressString(
      this.addressToBinary(this.maskedAddress).join("."),
      s
    );
  getSlicedBinaryAddress = (s) =>
    sliceBinaryIpAddressString(this.addressToBinary(this.address).join("."), s);
  getSlicedBinaryMask = (s) =>
    sliceBinaryIpAddressString(this.addressToBinary(this.mask).join("."), s);
  getAddressesNumber = (s) => 2 ** (32 - s);
  getHostsNumber = (s) => {
    let e = 2 ** (32 - s);
    return e - 2 < 1 ? 1 : e - 2;
  };
}
